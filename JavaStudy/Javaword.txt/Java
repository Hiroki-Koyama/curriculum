■Javadoc
    Java言語のソースコードから「プログラムについて説明するドキュメント」を生成する仕組み
    /**
    * これがJavadoc用のコメントの書き方です。
    */
    クラスやメソッドなど、Java言語の構成要素とその説明が対応づけられているため、多人数で開発をする場合などに役立つ
    フォーマットが決まっており、メソッド全体についてのコメントを書くため 意味のない情報を書くことが少なくなる


■アノテーション
    annotation、注釈と言う意味
    クラスやインタフェース、メソッドやフィールド、パッケージなどに対してメタデータとして付加情報を記入する機能
    開発者がソースコードにコメントを自由に記述すると、統一性がなくなり、同じ内容をさまざまな表現で書いてしまいます。これを防ぎ、重要な情報について統一的な表現で記述したいときは、「アノテーション」を使う


■メモリ管理
    コンピュータのメモリを管理する

  ・ヒープ
      ヒープを使うと「必要になった時に必要なぶんだけメモリを確保する」ことができる
      OSやアプリケーションソフトが使用するメモリ領域の一種
      用途に関係なく自由に確保することができる

      配列定義では、配列のサイズは定数でなければならず、 コンパイル時にサイズが決まっていなければならない
      ファイルから次々データを読み込むような場合、 ファイルの内容を実際に読み出してみなければ、データの個数がわからないことが多い
      コンパイル時にサイズを 1000 と決めてしまうと、 データが 1000 個より多いときには対応できません。 それなら、と 1000000 にしてしまうとメモリをムダ使いする場合が多い
      配列のようなものを確保できるが、 そのサイズや個数をプログラムの実行が始まったあとで決めて良いそのようなしくみは動的メモリ割り当てという
      そのために用意されているメモリ領域をヒープ領域 (または短い呼び方で「ヒープ(heap)」)という
    JVM
      JVMは自動でメモリの管理を行う
      JavaはJVM(Java Virtual Machine)と呼ばれる仮想マシン上で動作している
      APIやいくつかのツールとセットでJava実行環境 (JRE) としてリリースされている
      この環境を移植することで，さまざまな環境でJavaのプログラムを実行することができる

  ・GC
      ヒープにおけるGCは「ScanvengeGC」と「FullGC」の2種類ある
    ScanvebgeGC
      New領域に対するGC。負荷が低く速い。頻繁に行われる。
    FullGC
      OldおよびPermanent領域に対するGC。負荷が高く遅い。FullGCが行われている間はアプリケーションが停止状態となるため、頻発させないことが望ましい

      JVMは自動でメモリの管理を行います。具体的にはヒープに格納されているオブジェクトのうち、不要となったものを削除する＝ガベージコレクション（GC）を勝手にやってくれる


■GoF
    Gang of Four（ギャング・オブ・フォー、GoF）
    書籍『オブジェクト指向における再利用のためのデザインパターン』の著者であるエーリヒ・ガンマ、リチャード・ヘルム、ラルフ・ジョンソン、ジョン・ブリシディースの4人を指す
    オブジェクト指向プログラミングにおける再利用性の高いコーディングのパターン、デザインパターンをまとめた4人を指す


■デザインパターン
    設計者が何か問題に直面したとき、そのような問題に出会うのが初めてであれば、いろいろ試行錯誤をして良い解決方法を見つける必要があります。しかし、以前似たような問題に出会い、うまく解決した経験があれば、以前と同じような方法でその問題を解決することができるのです。「よく出会う問題とそれに対処する良い設計」をたくさん知っていれば、良い設計をスムースに進めていくことができる

  デザインパターンの目的
    ベストプラクティスを体得する
      エンジニアが試行錯誤した結果を、少ない時間で体得する（利用する）ことができるのです。プログラミングの効率化もできますし、先人のアイデアを学ぶこともできる
    再利用性の高いコードを書く
      再利用性の高いコードを書くこともできる
      コードの見通しも良くなり、メンテナンス性も高まる
    エンジニア同士の共通言語にする
      デザインパターンが考慮されたコードは、他のエンジニアにとっても読みやすいコードになる

    デザインパターンの種類
    1.Template Method
      処理の一部をサブクラスで実装。よくある継承。

    2.Singleton
      生成するオブジェクトの数を制限する。

    3.Adapter
      APIの異なるクラス同士をつなぎ合わせる。継承と移譲の2通りのやり方があるが、基本どちらもAdapterメソッド内でつなぎ合わせ先のメソッドを呼ぶ形になる。

    4.Factory Method
      クラスの処理(例:csv,xmlファイルを読み込む)とどのクラスを呼ぶか決める。流れは同じだけど、処理(例:それぞれのファイルの読み込み方)がものによって別のものに使える。

    5.Facade
      ファサード。仏語で窓口。クラス同士の複雑な関係を意識しなくていいように、窓口を一つ与える。

    6.Iterator
      不規則な多次元配列でも、内部構造を意識せずにそれぞれの要素にアクセスできる。
      phpならSPLの機能のIteratorインターフェース等を継承させる。

    7.Abstract Factory
      例えば扱うデータがDBかMOCKか最初に宣言すれば、あとは芋づる式にそれぞれの処理のクラスが使われるようになる。
    
    8.Bridge
      機能(例:ボタンを押す)と実装(例:押したらクイックソートされる)を分ける。
      インターフェースが利用者に提供するAPIを定義することで機能と実装の橋渡しがされる。

    9.Builder
      異なる材料(例:読み込ませるファイル)だが同じ手順(open,read,close)でオブジェクトを生成させる。

    10.Chain of Responsibility
      よくやるフォームのバリデーションみたいな。オブジェクト同士の結びつきを緩める。

    11.Command
      要求に対する受付と処理を切り離して実装できる。またクラスに実装したコマンド結果を保持させているので、UndoやRedoもできる。

    12.Composite
      木構造を表す。単一のオブジェクトとオブジェクトの集合体を混ぜてアクセス方法を同じに。(例:組織とそれに属する社員を表示させる。)

    13.Decorator
      基本となるものに様々な機能を付け加えていく。追加する側のクラスが、される側のクラスのインスタンスを保持しているため、ユーザー側は追加機能が加えられていようがいなくまいが同一視して扱える。(例：入力した文字を加工し表示する)

    14.Flyweight
      一度インスタンス化したオブジェクトを、生成時に読み込んだ内容を保持させることでオブジェクトを使い回す。生成されるオブジェクトの時間やリソースが抑えられる。ただし、使い回して良いオブジェクトは環境によって変化しないものに限る。

    15.Interpreter
      字句解析(文字列を意味ある字句に分解)と構文解析(分解した字句それぞれが文法に従っているかチェック)を行った構文木を処理するパターン。ミニ言語とか作れてしまう。

    16.Mediator
      オブジェクト同士の依存や関係を把握・仲介してくれるもの(例：ユーザーとチャットルームの管理)

    17.Mement(Snapshot)
      ある時点でのオブジェクトの中身を記憶し、あとで思い出せるようにする。

    18.Observer
      あるオブジェクトの状態が変化した時に、関係する他のすべてのオブジェクトに通知とそれに応じた処理を行わせる。

    19.Prototype
      インスタンスをコピーして新しいインスタンスを生成する。深いコピーと浅いコピー(中身のオブジェクトも複製するか否か)がある。

    20.Proxy
      身代わりとなるオブジェクトを通じて、目的のオブジェクトにアクセスさせる。

    21.State
      状態をクラスで表し、状態ごとに振る舞いを切り替えられるようにする。

    22.Strategy
      パターンごとの処理のクラスを用意。それにアクセスするための処理を書いたクラスを用意。

    23.Visitor
      データ構造とそれに対する処理(操作がデータ構造を渡り歩く)を別々にする。